{% extends "base.html" %}

{% block title %}Technical Analysis{% endblock %}

{% block content %}
<div class="container mt-4">
    <!-- Token Selection -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="mb-0">
                        <i class="fas fa-chart-bar me-2"></i>Technical Analysis
                    </h5>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-4">
                            <label class="form-label">Select Token</label>
                            <div class="dropdown-container position-relative">
                                <div class="dropdown">
                                    <button class="btn btn-outline-secondary dropdown-toggle w-100 text-start" type="button" 
                                            id="tokenDropdownButton" data-bs-toggle="dropdown" aria-expanded="false">
                                        <span id="selected-token-text">Choose a token...</span>
                                    </button>
                                    <div class="dropdown-menu w-100" id="tokenDropdownMenu" style="max-height: 300px; overflow-y: auto;">
                                        <div class="p-2 border-bottom">
                                            <input type="text" class="form-control form-control-sm" id="token-search" 
                                                   placeholder="Search tokens..." onkeyup="filterTokens()" onclick="event.stopPropagation()">
                                        </div>
                                        <div id="token-list">
                                            <!-- Tokens will be populated here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-8">
                            <label class="form-label">Quick Actions</label>
                            <div>
                                <button class="btn btn-primary me-2" onclick="loadTokenAnalysis()">
                                    <i class="fas fa-sync me-1"></i>Refresh Analysis
                                </button>
                                <button class="btn btn-secondary" onclick="loadAllSignals()">
                                    <i class="fas fa-list me-1"></i>View All Signals
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Analysis Results -->
    <div class="row" id="analysis-results" style="display: none;">
        <div class="col-md-8">
            <!-- Price Chart -->
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h6 class="mb-0">
                        <i class="fas fa-chart-line me-2"></i>
                        Price Chart - <span id="chart-token-name">Select Token</span>
                    </h6>
                    <div class="btn-group btn-group-sm" role="group">
                        <button type="button" class="btn btn-outline-primary" id="pan-tool" onclick="togglePanMode()" title="Pan Mode">
                            <i class="fas fa-arrows-alt"></i> Pan
                        </button>
                        <button type="button" class="btn btn-outline-primary" id="zoom-reset" onclick="resetZoom()" title="Reset Zoom">
                            <i class="fas fa-search-minus"></i> Reset
                        </button>
                        <button type="button" class="btn btn-outline-primary" id="draw-line" onclick="toggleDrawingMode('line')" title="Draw Trend Lines">
                            <i class="fas fa-minus"></i> Line
                        </button>
                        <button type="button" class="btn btn-outline-primary" id="draw-rectangle" onclick="toggleDrawingMode('rectangle')" title="Draw Support/Resistance Box">
                            <i class="fas fa-square"></i> Box
                        </button>
                        <button type="button" class="btn btn-outline-danger" id="clear-drawings" onclick="clearDrawings()" title="Clear All Drawings">
                            <i class="fas fa-eraser"></i> Clear
                        </button>
                    </div>
                </div>
                <div class="card-body position-relative">
                    <div style="position: relative; height: 400px;">
                        <canvas id="price-chart" height="400" style="position: absolute; top: 0; left: 0;"></canvas>
                        <canvas id="drawing-canvas" height="400" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 10;"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="col-md-4">
            <!-- Trading Signal -->
            <div class="card mb-4">
                <div class="card-header">
                    <h6 class="mb-0">Trading Signal</h6>
                </div>
                <div class="card-body text-center">
                    <div id="signal-badge" class="mb-3"></div>
                    <div id="confidence-display" class="mb-3"></div>
                    <p class="text-muted" id="signal-description"></p>
                </div>
            </div>

            <!-- Trade Setup -->
            <div class="card mb-4" id="trade-setup-card" style="display: none;">
                <div class="card-header">
                    <h6 class="mb-0">
                        <i class="fas fa-cog me-2"></i>Trade Setup
                    </h6>
                </div>
                <div class="card-body">
                    <div id="trade-setup-content">
                        <!-- Trade setup details will be populated here -->
                    </div>
                    <button class="btn btn-primary btn-sm mt-3" onclick="copyTradeSetup()">
                        <i class="fas fa-copy me-1"></i>Copy Settings
                    </button>
                </div>
            </div>

            <!-- Key Metrics -->
            <div class="card">
                <div class="card-header">
                    <h6 class="mb-0">Key Metrics</h6>
                </div>
                <div class="card-body">
                    <table class="table table-sm">
                        <tbody id="metrics-table">
                            <!-- Metrics will be populated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Technical Indicators -->
    <div class="row" id="indicators-section" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h6 class="mb-0">Technical Indicators</h6>
                </div>
                <div class="card-body">
                    <div class="row">
                        <div class="col-md-6">
                            <h6>Trend Analysis</h6>
                            <table class="table table-sm">
                                <tbody id="trend-indicators">
                                    <!-- Trend indicators will be populated here -->
                                </tbody>
                            </table>
                        </div>
                        <div class="col-md-6">
                            <h6>Momentum & Volume</h6>
                            <table class="table table-sm">
                                <tbody id="momentum-indicators">
                                    <!-- Momentum indicators will be populated here -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Loading State -->
    <div class="row" id="analysis-loading">
        <div class="col-12">
            <div class="card">
                <div class="card-body text-center py-5">
                    <i class="fas fa-chart-line fa-3x text-muted mb-3"></i>
                    <h5>Technical Analysis</h5>
                    <p class="text-muted">Select a token above to view detailed technical analysis with charts and indicators.</p>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Analysis page functionality
let currentChart = null;
let tokens = [];
let allTokens = [];
let selectedTokenSymbol = '';

// Load page data
document.addEventListener('DOMContentLoaded', function() {
    loadAvailableTokens();
});

function loadAvailableTokens() {
    fetch('/api/tokens')
        .then(response => response.json())
        .then(data => {
            tokens = data.tokens || data;
            populateTokenSelect(tokens);
        })
        .catch(error => {
            console.error('Error loading tokens:', error);
        });
}

function populateTokenSelect(tokens) {
    allTokens = tokens; // Store for filtering
    renderTokenList(tokens);
}

function renderTokenList(tokens) {
    const tokenList = document.getElementById('token-list');
    tokenList.innerHTML = '';
    
    // Group tokens by availability
    const coreTokens = tokens.filter(token => token.status === 'core');
    const extendedTokens = tokens.filter(token => token.status === 'extended');
    const limitedTokens = tokens.filter(token => token.status === 'limited');
    
    // Add core tokens section
    if (coreTokens.length > 0) {
        const coreHeader = document.createElement('h6');
        coreHeader.className = 'dropdown-header text-success';
        coreHeader.innerHTML = '<i class="fas fa-check-circle me-1"></i>Core Tokens (Guaranteed Data)';
        tokenList.appendChild(coreHeader);
        
        coreTokens.forEach(token => {
            const item = createTokenItem(token, 'text-success');
            tokenList.appendChild(item);
        });
        
        if (extendedTokens.length > 0 || limitedTokens.length > 0) {
            tokenList.appendChild(document.createElement('hr'));
        }
    }
    
    // Add extended tokens section
    if (extendedTokens.length > 0) {
        const extendedHeader = document.createElement('h6');
        extendedHeader.className = 'dropdown-header text-warning';
        extendedHeader.innerHTML = '<i class="fas fa-clock me-1"></i>Extended Tokens (Rate Limited)';
        tokenList.appendChild(extendedHeader);
        
        extendedTokens.forEach(token => {
            const item = createTokenItem(token, 'text-warning');
            tokenList.appendChild(item);
        });
        
        if (limitedTokens.length > 0) {
            tokenList.appendChild(document.createElement('hr'));
        }
    }
    
    // Add limited tokens section (disabled)
    if (limitedTokens.length > 0) {
        const limitedHeader = document.createElement('h6');
        limitedHeader.className = 'dropdown-header text-muted';
        limitedHeader.innerHTML = '<i class="fas fa-lock me-1"></i>Limited Tokens (Requires API Upgrade)';
        tokenList.appendChild(limitedHeader);
        
        limitedTokens.forEach(token => {
            const item = createTokenItem(token, 'text-muted', true);
            tokenList.appendChild(item);
        });
    }
}

function createTokenItem(token, colorClass, disabled = false) {
    const item = document.createElement('a');
    item.className = `dropdown-item d-flex justify-content-between align-items-center ${disabled ? 'disabled' : ''}`;
    item.href = '#';
    item.style.cursor = disabled ? 'not-allowed' : 'pointer';
    
    if (!disabled) {
        item.onclick = (e) => {
            e.preventDefault();
            selectToken(token.symbol, `${token.symbol} - ${token.name}`);
        };
    }
    
    item.innerHTML = `
        <div>
            <strong class="${colorClass}">${token.symbol}</strong>
            <small class="text-muted d-block">${token.name}</small>
        </div>
        <i class="fas fa-chevron-right text-muted" style="font-size: 0.8em;"></i>
    `;
    
    return item;
}

function selectToken(symbol, displayText) {
    selectedTokenSymbol = symbol;
    document.getElementById('selected-token-text').textContent = displayText;
    
    // Close dropdown
    const dropdown = bootstrap.Dropdown.getInstance(document.getElementById('tokenDropdownButton'));
    if (dropdown) {
        dropdown.hide();
    }
    
    // Clear search
    document.getElementById('token-search').value = '';
    
    // Load analysis
    loadTokenAnalysis();
}

function filterTokens() {
    const searchInput = document.getElementById('token-search');
    const searchTerm = searchInput.value.toLowerCase();
    
    let filteredTokens;
    if (searchTerm.length === 0) {
        filteredTokens = allTokens;
    } else {
        filteredTokens = allTokens.filter(token => 
            token.symbol.toLowerCase().includes(searchTerm) || 
            token.name.toLowerCase().includes(searchTerm)
        );
    }
    
    renderTokenList(filteredTokens);
}

function loadTokenAnalysis() {
    if (!selectedTokenSymbol) {
        showLoadingState();
        return;
    }

    showAnalysisLoading();
    
    // Load analysis data
    Promise.all([
        fetch(`/api/chart-analysis/${selectedTokenSymbol}`),
        fetch(`/api/price-data/${selectedTokenSymbol}`)
    ])
    .then(responses => {
        // Check if responses are ok
        responses.forEach(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
        });
        return Promise.all(responses.map(r => r.json()));
    })
    .then(([analysisData, priceData]) => {
        console.log('Analysis data received:', analysisData);
        console.log('Price data received:', priceData);
        displayAnalysis(selectedTokenSymbol, analysisData, priceData);
        showAnalysisResults();
    })
    .catch(error => {
        console.error('Error loading analysis:', error);
        showError(`Error loading analysis for ${selectedTokenSymbol}: ${error.message}`);
    });
}

function displayAnalysis(symbol, analysis, priceData) {
    console.log('displayAnalysis called with:', symbol, analysis, priceData);
    
    try {
        // Update chart token name
        const chartTokenName = document.getElementById('chart-token-name');
        if (chartTokenName) {
            chartTokenName.textContent = symbol;
        }
        
        // Display trading signal
        displayTradingSignal(analysis);
        
        // Display key metrics
        displayKeyMetrics(analysis);
        
        // Display technical indicators
        displayTechnicalIndicators(analysis.technical_indicators || {});
        
        // Create price chart
        createPriceChart(priceData.data || priceData);
        
        console.log('Analysis display completed successfully');
    } catch (error) {
        console.error('Error in displayAnalysis:', error);
        showError(`Failed to display analysis: ${error.message}`);
    }
}

function displayTradingSignal(analysis) {
    try {
        const signalBadge = document.getElementById('signal-badge');
        const confidenceDisplay = document.getElementById('confidence-display');
        const signalDescription = document.getElementById('signal-description');
        
        const signal = analysis.recommendation || 'HOLD';
        const confidence = Math.round((analysis.confidence || 0) * 100);
        
        console.log('Displaying signal:', signal, 'Confidence:', confidence);
        
        // Signal badge
        if (signalBadge) {
            const badgeClass = signal === 'BUY' ? 'bg-success' : signal === 'SELL' ? 'bg-danger' : 'bg-secondary';
            signalBadge.innerHTML = `<span class="badge ${badgeClass} fs-4">${signal}</span>`;
        }
        
        // Confidence display
        if (confidenceDisplay) {
            const confidenceClass = confidence >= 70 ? 'text-success' : confidence >= 50 ? 'text-warning' : 'text-danger';
            confidenceDisplay.innerHTML = `
                <div class="progress mb-2">
                    <div class="progress-bar ${confidenceClass.replace('text-', 'bg-')}" 
                         style="width: ${confidence}%"></div>
                </div>
                <small class="${confidenceClass}">Confidence: ${confidence}%</small>
            `;
        }
        
        // Signal description
        if (signalDescription) {
            const descriptions = {
                'BUY': 'Technical indicators suggest a bullish trend. Consider entering a long position.',
                'SELL': 'Technical indicators suggest a bearish trend. Consider exiting positions or going short.',
                'HOLD': 'Mixed signals or neutral trend. Wait for clearer market direction.'
            };
            signalDescription.textContent = descriptions[signal];
        }
        
        // Display trade setup if signal is actionable
        if (signal !== 'HOLD') {
            displayTradeSetup(analysis, signal);
        }
        
        console.log('Trading signal displayed successfully');
    } catch (error) {
        console.error('Error displaying trading signal:', error);
    }
}

function displayTradeSetup(analysis, signal) {
    try {
        const tradeSetupCard = document.getElementById('trade-setup-card');
        const tradeSetupContent = document.getElementById('trade-setup-content');
        
        if (!tradeSetupCard || !tradeSetupContent) {
            console.log('Trade setup elements not found');
            return;
        }
        
        const currentPrice = analysis.current_price || 0;
        const confidence = Math.round((analysis.confidence || 0) * 100);
        const volatility = analysis.volatility || 15;
        
        // Calculate trade parameters
        const leverage = calculateOptimalLeverage(volatility);
        const accountBalance = 53.13; // Current account balance
        const riskPercentage = 5; // 5% risk per trade
        const riskAmount = accountBalance * (riskPercentage / 100);
    
    let stopLoss, takeProfit, qty;
    
    if (signal === 'BUY') {
        stopLoss = currentPrice * 0.97; // 3% stop loss
        takeProfit = currentPrice * 1.06; // 6% take profit
    } else { // SELL
        stopLoss = currentPrice * 1.03; // 3% stop loss
        takeProfit = currentPrice * 0.94; // 6% take profit
    }
    
    // Calculate position size
    const stopLossDistance = Math.abs(currentPrice - stopLoss);
    const positionValue = riskAmount / (stopLossDistance / currentPrice);
    qty = (positionValue / currentPrice).toFixed(4);
    
    const symbol = selectedTokenSymbol || 'TOKEN';
    
    tradeSetupContent.innerHTML = `
        <div class="row g-2">
            <div class="col-6">
                <small class="text-muted">Symbol:</small>
                <div class="fw-bold">${symbol}USDT</div>
            </div>
            <div class="col-6">
                <small class="text-muted">Side:</small>
                <div class="fw-bold text-${signal === 'BUY' ? 'success' : 'danger'}">${signal}</div>
            </div>
            <div class="col-6">
                <small class="text-muted">Order Type:</small>
                <div>Market</div>
            </div>
            <div class="col-6">
                <small class="text-muted">Leverage:</small>
                <div class="fw-bold">${leverage}x</div>
            </div>
            <div class="col-6">
                <small class="text-muted">Quantity:</small>
                <div class="fw-bold">${qty}</div>
            </div>
            <div class="col-6">
                <small class="text-muted">Margin Mode:</small>
                <div>Isolated</div>
            </div>
            <div class="col-12">
                <small class="text-muted">Entry Price:</small>
                <div class="fw-bold">$${currentPrice.toFixed(6)}</div>
            </div>
            <div class="col-6">
                <small class="text-muted">Stop Loss:</small>
                <div class="text-danger">$${stopLoss.toFixed(6)}</div>
            </div>
            <div class="col-6">
                <small class="text-muted">Take Profit:</small>
                <div class="text-success">$${takeProfit.toFixed(6)}</div>
            </div>
            <div class="col-12">
                <small class="text-muted">Time in Force:</small>
                <div>GTC (Good Till Cancelled)</div>
            </div>
            <div class="col-12 mt-2">
                <small class="text-muted">Confidence Level:</small>
                <div class="fw-bold text-primary">${confidence}%</div>
            </div>
        </div>
    `;
    
    // Store trade setup for copying
    window.currentTradeSetup = {
        symbol: `${symbol}USDT`,
        side: signal,
        orderType: 'Market',
        qty: qty,
        leverage: leverage,
        marginMode: 'isolated',
        entryPrice: currentPrice.toFixed(6),
        stopLoss: stopLoss.toFixed(6),
        takeProfit: takeProfit.toFixed(6),
        timeInForce: 'GTC',
        riskAmount: riskAmount.toFixed(2),
        riskPercentage: riskPercentage,
        confidence: confidence
    };
    
    tradeSetupCard.style.display = 'block';
        
        console.log('Trade setup displayed');
    } catch (error) {
        console.error('Error displaying trade setup:', error);
    }
}

function calculateOptimalLeverage(volatility) {
    // Conservative leverage based on volatility
    if (volatility > 20) return 3;
    if (volatility > 15) return 5;
    if (volatility > 10) return 8;
    return 10;
}

function getCurrentTokenSymbol() {
    return selectedTokenSymbol || null;
}

function copyTradeSetup() {
    if (!window.currentTradeSetup) return;
    
    const setup = window.currentTradeSetup;
    const text = `Bybit Futures Trade Setup:
Symbol: ${setup.symbol}
Side: ${setup.side}
Order Type: ${setup.orderType}
Quantity: ${setup.qty}
Leverage: ${setup.leverage}x
Margin Mode: ${setup.marginMode}
Entry Price: $${setup.entryPrice}
Stop Loss: $${setup.stopLoss}
Take Profit: $${setup.takeProfit}
Time in Force: ${setup.timeInForce}

Confidence: ${setup.confidence}%`;
    
    navigator.clipboard.writeText(text).then(() => {
        const btn = event.target;
        const originalText = btn.innerHTML;
        btn.innerHTML = '<i class="fas fa-check me-1"></i>Copied!';
        btn.classList.add('btn-success');
        btn.classList.remove('btn-primary');
        
        setTimeout(() => {
            btn.innerHTML = originalText;
            btn.classList.remove('btn-success');
            btn.classList.add('btn-primary');
        }, 2000);
    }).catch(err => {
        console.error('Failed to copy: ', err);
        alert('Failed to copy to clipboard');
    });
}

function displayKeyMetrics(analysis) {
    try {
        const table = document.getElementById('metrics-table');
        
        if (!table) {
            console.log('Metrics table not found');
            return;
        }
    
        const metrics = [
            ['Current Price', `$${formatPrice(analysis.current_price || 0)}`],
            ['24h Change', formatPercentage(analysis.price_change_24h || 0)],
            ['7d Change', formatPercentage(analysis.price_change_7d || 0)],
            ['Volume 24h', `$${(analysis.volume_24h || 0).toLocaleString()}`],
            ['Volatility', `${analysis.volatility || 0}%`],
            ['Confidence', `${Math.round((analysis.confidence || 0) * 100)}%`],
            ['Analysis Quality', analysis.analysis_quality || 'N/A'],
            ['Last Updated', new Date(analysis.last_updated).toLocaleString()]
        ];
        
        table.innerHTML = metrics.map(([label, value]) => `
            <tr>
                <td><strong>${label}:</strong></td>
                <td>${value}</td>
            </tr>
        `).join('');
        
        console.log('Key metrics displayed');
    } catch (error) {
        console.error('Error displaying key metrics:', error);
    }
}

function displayTechnicalIndicators(indicators) {
    try {
        const trendTable = document.getElementById('trend-indicators');
        const momentumTable = document.getElementById('momentum-indicators');
        
        if (!trendTable || !momentumTable) {
            console.log('Technical indicator tables not found');
            return;
        }
        
        // Trend indicators
        const trendData = [
            ['SMA Trend', indicators.sma_trend || 'N/A'],
            ['MACD Trend', indicators.macd_trend || 'N/A'],
            ['Support Levels', indicators.support_levels || 0],
            ['Resistance Levels', indicators.resistance_levels || 0]
        ];
        
        trendTable.innerHTML = trendData.map(([label, value]) => `
            <tr>
                <td><strong>${label}:</strong></td>
                <td>${value}</td>
            </tr>
        `).join('');
        
        // Momentum indicators
        const momentumData = [
            ['RSI', Math.round(indicators.rsi || 0)],
            ['Price Momentum', indicators.price_momentum || 'N/A'],
            ['Trend Strength', Math.round((indicators.trend_strength || 0) * 100) + '%'],
            ['Volume Ratio', indicators.volume_ratio ? indicators.volume_ratio.toFixed(2) : 'N/A']
        ];
        
        momentumTable.innerHTML = momentumData.map(([label, value]) => `
            <tr>
                <td><strong>${label}:</strong></td>
                <td>${value}</td>
            </tr>
        `).join('');
        
        console.log('Technical indicators displayed');
    } catch (error) {
        console.error('Error displaying technical indicators:', error);
    }
}

function createPriceChart(priceData) {
    try {
        const ctx = document.getElementById('price-chart').getContext('2d');
        
        // Destroy existing chart
        if (currentChart) {
            currentChart.destroy();
        }
        
        if (!priceData || !Array.isArray(priceData) || priceData.length === 0) {
            console.log('Creating chart with data:', priceData, 'points');
            // Create empty chart with message
            ctx.fillStyle = '#8b949e';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('No chart data available', ctx.canvas.width / 2, ctx.canvas.height / 2);
            return;
        }
        
        console.log('Creating chart with', priceData.length, 'data points');
        
        const labels = priceData.map(d => new Date(d.timestamp).toLocaleTimeString());
        const prices = priceData.map(d => d.price);
        
        currentChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Price',
                data: prices,
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.1)',
                tension: 0.1,
                fill: true
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    grid: { 
                        color: 'rgba(255, 255, 255, 0.1)' 
                    },
                    ticks: { 
                        color: '#fff',
                        maxTicksLimit: 10
                    }
                },
                y: {
                    beginAtZero: false,
                    grid: { 
                        color: 'rgba(255, 255, 255, 0.1)' 
                    },
                    ticks: {
                        color: '#fff',
                        callback: function(value) {
                            return '$' + value.toFixed(2);
                        }
                    }
                }
            }
        }
    });
    
    } catch (error) {
        console.error('Error creating chart:', error);
        const ctx = document.getElementById('price-chart').getContext('2d');
        ctx.fillStyle = '#8b949e';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Chart loading error', ctx.canvas.width / 2, ctx.canvas.height / 2);
    }
}

function loadAllSignals() {
    window.location.href = '/';
}

function showAnalysisResults() {
    document.getElementById('analysis-loading').style.display = 'none';
    document.getElementById('analysis-results').style.display = 'block';
    document.getElementById('indicators-section').style.display = 'block';
}

function showLoadingState() {
    document.getElementById('analysis-results').style.display = 'none';
    document.getElementById('indicators-section').style.display = 'none';
    document.getElementById('analysis-loading').style.display = 'block';
}

function showAnalysisLoading() {
    const loadingDiv = document.getElementById('analysis-loading');
    const resultsDiv = document.getElementById('analysis-results');
    
    if (loadingDiv) {
        loadingDiv.innerHTML = `
            <div class="col-12">
                <div class="card">
                    <div class="card-body text-center py-5">
                        <div class="spinner-border text-primary mb-3" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <h5>Analyzing ${selectedTokenSymbol || 'Token'}</h5>
                        <p class="text-muted">Running technical analysis...</p>
                    </div>
                </div>
            </div>
        `;
        loadingDiv.style.display = 'block';
    }
    
    if (resultsDiv) {
        resultsDiv.style.display = 'none';
    }
}

function showLoadingState() {
    const resultsDiv = document.getElementById('analysis-results');
    const loadingDiv = document.getElementById('analysis-loading');
    if (resultsDiv) resultsDiv.style.display = 'none';
    if (loadingDiv) loadingDiv.style.display = 'block';
}

function showAnalysisResults() {
    const loadingDiv = document.getElementById('analysis-loading');
    const resultsDiv = document.getElementById('analysis-results');
    const indicatorsDiv = document.getElementById('indicators-section');
    
    if (loadingDiv) loadingDiv.style.display = 'none';
    if (resultsDiv) resultsDiv.style.display = 'block';
    if (indicatorsDiv) indicatorsDiv.style.display = 'block';
    
    console.log('Analysis results shown');
}

function showError(message) {
    const loadingDiv = document.getElementById('analysis-loading');
    if (loadingDiv) {
        loadingDiv.innerHTML = `
            <div class="col-12">
                <div class="card">
                    <div class="card-body text-center py-4">
                        <i class="fas fa-exclamation-triangle text-warning mb-3" style="font-size: 2rem;"></i>
                        <h5>Error</h5>
                        <p class="text-muted">${message}</p>
                        <button class="btn btn-primary" onclick="loadTokenAnalysis()">Try Again</button>
                    </div>
                </div>
            </div>
        `;
        loadingDiv.style.display = 'block';
    }
}

function formatPrice(price) {
    if (price >= 1000) {
        return price.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0});
    } else if (price >= 1) {
        return price.toFixed(2);
    } else {
        return price.toFixed(4);
    }
}

function formatPercentage(value) {
    if (value === null || value === undefined) return 'N/A';
    const formatted = (value >= 0 ? '+' : '') + value.toFixed(2) + '%';
    return `<span class="${value >= 0 ? 'text-success' : 'text-danger'}">${formatted}</span>`;
}

// Chart interaction variables
let isDragging = false;
let lastX = 0;
let lastY = 0;
let zoomLevel = 1;
let panOffsetX = 0;
let panOffsetY = 0;

// Chart Tools Variables
let priceChart = null;
let drawingCanvas = null;
let drawingContext = null;
let isPanMode = false;
let drawingMode = null;
let isDrawing = false;
let drawings = [];
let startPoint = null;

// Initialize drawing canvas
function initializeDrawingCanvas() {
    drawingCanvas = document.getElementById('drawing-canvas');
    if (drawingCanvas) {
        drawingContext = drawingCanvas.getContext('2d');
        drawingCanvas.width = drawingCanvas.offsetWidth;
        drawingCanvas.height = drawingCanvas.offsetHeight;
        
        // Add mouse event listeners for drawing
        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', draw);
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseout', stopDrawing);
    }
}

// Add interactive functionality to chart
function addChartInteractivity(canvas) {
    // Mouse wheel zoom
    canvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const zoom = e.deltaY > 0 ? 0.9 : 1.1;
        zoomLevel *= zoom;
        
        // Apply zoom to chart
        if (priceChart) {
            const xScale = priceChart.scales.x;
            const yScale = priceChart.scales.y;
            
            const range = xScale.max - xScale.min;
            const center = xScale.min + range / 2;
            const newRange = range * (1 / zoom);
            
            xScale.options.min = center - newRange / 2;
            xScale.options.max = center + newRange / 2;
            
            priceChart.update('none');
        }
        
        console.log('Zoom applied:', zoomLevel);
    });
    
    // Mouse drag pan
    canvas.addEventListener('mousedown', function(e) {
        if (isPanMode) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
            canvas.style.cursor = 'grabbing';
        }
    });
    
    canvas.addEventListener('mousemove', function(e) {
        if (isDragging && isPanMode && priceChart) {
            const deltaX = e.clientX - lastX;
            const deltaY = e.clientY - lastY;
            
            const xScale = priceChart.scales.x;
            const range = xScale.max - xScale.min;
            const panAmount = range * (deltaX / canvas.width) * 0.1;
            
            xScale.options.min -= panAmount;
            xScale.options.max -= panAmount;
            
            priceChart.update('none');
            
            lastX = e.clientX;
            lastY = e.clientY;
        }
    });
    
    canvas.addEventListener('mouseup', function(e) {
        if (isDragging) {
            isDragging = false;
            canvas.style.cursor = isPanMode ? 'grab' : 'default';
        }
    });
    
    canvas.addEventListener('mouseleave', function(e) {
        if (isDragging) {
            isDragging = false;
            canvas.style.cursor = 'default';
        }
    });
}

// Toggle pan mode
function togglePanMode() {
    const panBtn = document.getElementById('pan-tool');
    isPanMode = !isPanMode;
    
    if (isPanMode) {
        panBtn.classList.remove('btn-outline-primary');
        panBtn.classList.add('btn-primary');
        drawingMode = null;
        updateDrawingButtons();
        if (drawingCanvas) drawingCanvas.style.pointerEvents = 'none';
        console.log('Pan mode enabled - click and drag to move chart');
    } else {
        panBtn.classList.remove('btn-primary');
        panBtn.classList.add('btn-outline-primary');
        console.log('Pan mode disabled');
    }
}

// Reset zoom
function resetZoom() {
    if (priceChart) {
        // Reset zoom and pan
        zoomLevel = 1;
        panOffsetX = 0;
        panOffsetY = 0;
        
        // Reset scale options
        priceChart.scales.x.options.min = undefined;
        priceChart.scales.x.options.max = undefined;
        priceChart.scales.y.options.min = undefined;
        priceChart.scales.y.options.max = undefined;
        
        priceChart.update();
        console.log('Chart zoom and pan reset');
    }
}

// Toggle drawing mode
function toggleDrawingMode(mode) {
    const btn = document.getElementById(`draw-${mode}`);
    
    if (drawingMode === mode) {
        drawingMode = null;
        btn.classList.remove('btn-primary');
        btn.classList.add('btn-outline-primary');
        if (drawingCanvas) drawingCanvas.style.pointerEvents = 'none';
    } else {
        drawingMode = mode;
        isPanMode = false;
        updateDrawingButtons();
        btn.classList.remove('btn-outline-primary');
        btn.classList.add('btn-primary');
        if (drawingCanvas) drawingCanvas.style.pointerEvents = 'auto';
        
        // Disable pan mode
        const panBtn = document.getElementById('pan-tool');
        panBtn.classList.remove('btn-primary');
        panBtn.classList.add('btn-outline-primary');
        if (priceChart && priceChart.options.plugins.zoom) {
            priceChart.options.plugins.zoom.pan.enabled = false;
            priceChart.update('none');
        }
    }
}

function updateDrawingButtons() {
    ['line', 'rectangle'].forEach(mode => {
        const btn = document.getElementById(`draw-${mode}`);
        if (drawingMode === mode) {
            btn.classList.remove('btn-outline-primary');
            btn.classList.add('btn-primary');
        } else {
            btn.classList.remove('btn-primary');
            btn.classList.add('btn-outline-primary');
        }
    });
}

// Drawing functions
function startDrawing(event) {
    if (!drawingMode) return;
    
    isDrawing = true;
    const rect = drawingCanvas.getBoundingClientRect();
    startPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
}

function draw(event) {
    if (!isDrawing || !drawingMode || !startPoint) return;
    
    const rect = drawingCanvas.getBoundingClientRect();
    const currentPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
    
    // Clear canvas and redraw all existing drawings
    drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    redrawAllDrawings();
    
    // Draw current shape being created
    drawingContext.strokeStyle = '#00d4ff';
    drawingContext.lineWidth = 2;
    drawingContext.beginPath();
    
    if (drawingMode === 'line') {
        drawingContext.moveTo(startPoint.x, startPoint.y);
        drawingContext.lineTo(currentPoint.x, currentPoint.y);
    } else if (drawingMode === 'rectangle') {
        const width = currentPoint.x - startPoint.x;
        const height = currentPoint.y - startPoint.y;
        drawingContext.rect(startPoint.x, startPoint.y, width, height);
    }
    
    drawingContext.stroke();
}

function stopDrawing(event) {
    if (!isDrawing || !drawingMode || !startPoint) return;
    
    isDrawing = false;
    const rect = drawingCanvas.getBoundingClientRect();
    const endPoint = {
        x: event.clientX - rect.left,
        y: event.clientY - rect.top
    };
    
    // Save the drawing
    const drawing = {
        type: drawingMode,
        start: startPoint,
        end: endPoint,
        color: '#00d4ff'
    };
    
    drawings.push(drawing);
    startPoint = null;
}

function redrawAllDrawings() {
    drawings.forEach(drawing => {
        drawingContext.strokeStyle = drawing.color;
        drawingContext.lineWidth = 2;
        drawingContext.beginPath();
        
        if (drawing.type === 'line') {
            drawingContext.moveTo(drawing.start.x, drawing.start.y);
            drawingContext.lineTo(drawing.end.x, drawing.end.y);
        } else if (drawing.type === 'rectangle') {
            const width = drawing.end.x - drawing.start.x;
            const height = drawing.end.y - drawing.start.y;
            drawingContext.rect(drawing.start.x, drawing.start.y, width, height);
        }
        
        drawingContext.stroke();
    });
}

function clearDrawings() {
    drawings = [];
    if (drawingContext) {
        drawingContext.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }
}

// Update the createPriceChart function to initialize drawing canvas
function createPriceChart(priceData) {
    const ctx = document.getElementById('price-chart');
    if (!ctx) {
        console.log('Price chart canvas not found');
        return;
    }
    
    const context = ctx.getContext('2d');
    
    if (currentChart) {
        currentChart.destroy();
    }
    
    console.log('Creating chart with data:', priceData.length, 'points');
    
    const labels = priceData.map(item => new Date(item.timestamp).toLocaleDateString());
    const prices = priceData.map(item => item.price);
    
    console.log('Chart labels sample:', labels.slice(0, 3));
    console.log('Chart prices sample:', prices.slice(0, 3));
    
    currentChart = new Chart(context, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: selectedTokenSymbol || 'Price',
                data: prices,
                borderColor: '#00d4ff',
                backgroundColor: 'rgba(0, 212, 255, 0.1)',
                tension: 0.1,
                fill: true,
                pointRadius: 1,
                pointHoverRadius: 4,
                borderWidth: 2
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                intersect: false,
                mode: 'index'
            },
            plugins: {
                legend: {
                    display: false
                }
            },
            scales: {
                x: {
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: '#8b949e'
                    }
                },
                y: {
                    beginAtZero: false,
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    },
                    ticks: {
                        color: '#8b949e',
                        callback: function(value) {
                            return '$' + value.toFixed(2);
                        }
                    }
                }
            },
            onHover: (event, activeElements) => {
                if (isPanMode) {
                    event.native.target.style.cursor = 'grab';
                } else if (drawingMode) {
                    event.native.target.style.cursor = 'crosshair';
                } else {
                    event.native.target.style.cursor = 'default';
                }
            }
        }
    });
    
    console.log('Chart created successfully');
    
    // Add interactive functionality
    try {
        addChartInteractivity(ctx);
        
        // Initialize drawing canvas after chart is created
        setTimeout(() => {
            initializeDrawingCanvas();
            console.log('Interactive chart tools initialized');
        }, 100);
    } catch (error) {
        console.log('Chart interactivity setup skipped:', error.message);
    }
}

// Load tokens for dropdown selection
async function loadTokens() {
    try {
        const response = await fetch('/api/tokens');
        const data = await response.json();
        
        if (data.success && data.tokens) {
            const tokenList = document.getElementById('token-list');
            if (tokenList) {
                tokenList.innerHTML = data.tokens.map(token => `
                    <a class="dropdown-item token-item" href="#" data-symbol="${token.symbol}" onclick="selectToken('${token.symbol}', '${token.name}')">
                        <div class="d-flex justify-content-between align-items-center">
                            <div>
                                <strong>${token.symbol}</strong>
                                <small class="text-muted d-block">${token.name}</small>
                            </div>
                            <div class="text-end">
                                <div>$${formatPrice(token.price)}</div>
                                <small class="${token.change_24h >= 0 ? 'text-success' : 'text-danger'}">
                                    ${token.change_24h >= 0 ? '+' : ''}${token.change_24h.toFixed(2)}%
                                </small>
                            </div>
                        </div>
                    </a>
                `).join('');
            }
        }
    } catch (error) {
        console.error('Error loading tokens:', error);
        const tokenList = document.getElementById('token-list');
        if (tokenList) {
            tokenList.innerHTML = '<div class="dropdown-item text-center text-muted">Failed to load tokens</div>';
        }
    }
}

// Select a token from the dropdown
function selectToken(symbol, name) {
    selectedTokenSymbol = symbol;
    const selectedText = document.getElementById('selected-token-text');
    if (selectedText) {
        selectedText.textContent = `${symbol} - ${name}`;
    }
    
    // Trigger analysis for the selected token
    loadTokenAnalysis();
}

// Filter tokens in dropdown
function filterTokens() {
    const searchInput = document.getElementById('token-search');
    const tokenItems = document.querySelectorAll('.token-item');
    
    if (searchInput && tokenItems) {
        const searchTerm = searchInput.value.toLowerCase();
        
        tokenItems.forEach(item => {
            const symbol = item.dataset.symbol.toLowerCase();
            const text = item.textContent.toLowerCase();
            
            if (symbol.includes(searchTerm) || text.includes(searchTerm)) {
                item.style.display = 'block';
            } else {
                item.style.display = 'none';
            }
        });
    }
}

// Initialize page on load
document.addEventListener('DOMContentLoaded', function() {
    loadTokens();
    console.log('Analysis page initialized');
});
</script>
{% endblock %}